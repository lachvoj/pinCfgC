// Part 6: Error Decoder Tab functionality

// ERROR_CODES will be auto-generated from MyTransportErrors.h by build script
// Format: {0x00: {name: 'TSP_ERR_NONE', description: 'No error', severity: 'info'}, ...}

function setupErrorsTab() {
    // Set default boot time to current time
    const bootTimeInput = document.getElementById('bootTime');
    if (bootTimeInput) {
        const now = new Date();
        // Format: YYYY-MM-DDTHH:MM
        const formatted = now.toISOString().slice(0, 16);
        bootTimeInput.value = formatted;
    }
    
    // Setup decode button
    const decodeBtn = document.getElementById('decodeErrorsBtn');
    if (decodeBtn) {
        decodeBtn.addEventListener('click', decodeErrorLog);
    }
    
    // Setup clear button
    const clearBtn = document.getElementById('clearErrorsBtn');
    if (clearBtn) {
        clearBtn.addEventListener('click', clearErrorDecoder);
    }
}

function decodeErrorLog() {
    const inputField = document.getElementById('errorLogInput');
    const tableBody = document.getElementById('errorTableBody');
    const noErrorsMsg = document.getElementById('noErrorsMessage');
    const errorSummary = document.getElementById('errorSummary');
    const totalCountSpan = document.getElementById('errorTotalCount');
    const displayCountSpan = document.getElementById('errorDisplayCount');
    
    if (!inputField || !tableBody) return;
    
    const input = inputField.value.trim();
    
    if (!input) {
        showErrorDecoderMessage('Please paste an error log response first.');
        return;
    }
    
    // Parse format: T:<total>,C:<count>|<ts>,<code>,<ch>,<ex>|...
    const parsed = parseErrorLogResponse(input);
    
    if (!parsed) {
        showErrorDecoderMessage('Invalid error log format. Expected: T:&lt;total&gt;,C:&lt;count&gt;|&lt;ts&gt;,&lt;code&gt;,&lt;ch&gt;,&lt;ex&gt;|...');
        return;
    }
    
    // Get boot time
    const bootTimeInput = document.getElementById('bootTime');
    const bootTime = bootTimeInput ? new Date(bootTimeInput.value) : new Date();
    
    // Clear table
    tableBody.innerHTML = '';
    
    if (parsed.entries.length === 0) {
        if (noErrorsMsg) noErrorsMsg.style.display = 'block';
        if (errorSummary) errorSummary.style.display = 'none';
        showErrorDecoderMessage(`No error entries. Total errors since boot: ${parsed.total}`);
        return;
    }
    
    // Hide no errors message, show summary
    if (noErrorsMsg) noErrorsMsg.style.display = 'none';
    if (errorSummary) {
        errorSummary.style.display = 'flex';
        if (totalCountSpan) totalCountSpan.textContent = `Total errors since boot: ${parsed.total}`;
        if (displayCountSpan) displayCountSpan.textContent = `Showing: ${parsed.entries.length} entries`;
    }
    
    // Render entries
    parsed.entries.forEach(entry => {
        const row = createErrorRow(entry, bootTime);
        tableBody.appendChild(row);
    });
}

function parseErrorLogResponse(input) {
    // Format: T:<total>,C:<count>|<ts>,<code>,<ch>,<ex>|...
    // Or just the simple message: "No errors. Total: X"
    
    // Check for simple "No errors" message
    const noErrorsMatch = input.match(/No errors\.\s*Total:\s*(\d+)/i);
    if (noErrorsMatch) {
        return {
            total: parseInt(noErrorsMatch[1]),
            count: 0,
            entries: []
        };
    }
    
    // Parse full format
    const headerMatch = input.match(/T:(\d+),C:(\d+)/);
    if (!headerMatch) {
        return null;
    }
    
    const total = parseInt(headerMatch[1]);
    const count = parseInt(headerMatch[2]);
    
    // Parse entries
    const entries = [];
    const entryPattern = /\|(\d+),([0-9A-Fa-f]+),(\d+),(\d+)/g;
    let match;
    
    while ((match = entryPattern.exec(input)) !== null) {
        entries.push({
            timestamp: parseInt(match[1]),
            errorCode: parseInt(match[2], 16),
            channel: parseInt(match[3]),
            extra: parseInt(match[4])
        });
    }
    
    return { total, count, entries };
}

function createErrorRow(entry, bootTime) {
    const row = document.createElement('tr');
    
    // Get error info from ERROR_CODES (generated by build script)
    const errorInfo = getErrorInfo(entry.errorCode);
    
    // Apply severity class
    row.className = `error-row-${errorInfo.severity}`;
    
    // Time column
    const timeCell = document.createElement('td');
    timeCell.textContent = formatTimestamp(bootTime, entry.timestamp);
    row.appendChild(timeCell);
    
    // Code column
    const codeCell = document.createElement('td');
    codeCell.className = 'error-code';
    codeCell.textContent = '0x' + entry.errorCode.toString(16).toUpperCase().padStart(2, '0');
    row.appendChild(codeCell);
    
    // Name column
    const nameCell = document.createElement('td');
    nameCell.className = 'error-name';
    nameCell.textContent = errorInfo.name;
    row.appendChild(nameCell);
    
    // Channel column
    const channelCell = document.createElement('td');
    channelCell.textContent = entry.channel.toString();
    row.appendChild(channelCell);
    
    // Extra column
    const extraCell = document.createElement('td');
    extraCell.textContent = entry.extra.toString();
    // Add hex if > 9
    if (entry.extra > 9) {
        extraCell.textContent += ` (0x${entry.extra.toString(16).toUpperCase()})`;
    }
    row.appendChild(extraCell);
    
    // Description column
    const descCell = document.createElement('td');
    descCell.className = 'error-description';
    descCell.textContent = errorInfo.description;
    // Add context based on error type
    const context = getErrorContext(entry);
    if (context) {
        descCell.textContent += ` â€” ${context}`;
    }
    row.appendChild(descCell);
    
    return row;
}

function getErrorInfo(code) {
    // Check if ERROR_CODES is defined (from build script)
    if (typeof ERROR_CODES !== 'undefined' && ERROR_CODES[code]) {
        return ERROR_CODES[code];
    }
    
    // Fallback for unknown codes
    return {
        name: 'UNKNOWN',
        description: 'Unknown error code',
        severity: 'default'
    };
}

function getErrorSeverity(code) {
    // Critical: Bus-off, init failures, recovery failed
    const criticalCodes = [
        0x01, // INIT_FAILED
        0x0D, // RECOVERY_FAILED
        0x8B, // CAN_BUS_OFF
        0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80 // All init failures
    ];
    
    // Warning: Error states, threshold reached
    const warningCodes = [
        0x8C, // CAN_BUS_PASSIVE
        0x8D, // CAN_BUS_WARNING
        0x07, // RX_OVERFLOW
        0x09, // RX_QUEUE_FULL
        0x84, // TX_BUFFER_FULL
        0x8A  // CAN_RX_BUFFER_OVF
    ];
    
    // Info: Recovery OK, no error
    const infoCodes = [
        0x00, // NONE
        0x0C  // RECOVERY_OK
    ];
    
    if (criticalCodes.includes(code)) return 'critical';
    if (warningCodes.includes(code)) return 'warning';
    if (infoCodes.includes(code)) return 'info';
    return 'default';
}

function getErrorContext(entry) {
    const code = entry.errorCode;
    const extra = entry.extra;
    
    // CAN-specific context
    if (code >= 0x80 && code <= 0x94) {
        if (code === 0x8B || code === 0x8C || code === 0x8D) {
            // Bus error states - extra might be TEC or REC
            return `Error counter: ${extra}`;
        }
        if (code === 0x82 || code === 0x83) {
            // TX failed - extra might be frame number
            return extra > 0 ? `Frame #${extra}` : '';
        }
        if (code === 0x85) {
            // Lost arbitration
            return extra > 0 ? `At bit ${extra}` : '';
        }
    }
    
    // Generic context
    if (code === 0x05) {
        // No ACK - extra might be node ID
        return extra > 0 ? `Node ID: ${extra}` : '';
    }
    
    return '';
}

function formatTimestamp(bootTime, millis) {
    if (!bootTime || isNaN(bootTime.getTime())) {
        // Just show relative time
        return formatRelativeTime(millis);
    }
    
    // Calculate actual time
    const actualTime = new Date(bootTime.getTime() + millis);
    
    // Format as HH:MM:SS.mmm
    const hours = actualTime.getHours().toString().padStart(2, '0');
    const minutes = actualTime.getMinutes().toString().padStart(2, '0');
    const seconds = actualTime.getSeconds().toString().padStart(2, '0');
    const ms = actualTime.getMilliseconds().toString().padStart(3, '0');
    
    return `${hours}:${minutes}:${seconds}.${ms}`;
}

function formatRelativeTime(millis) {
    const seconds = Math.floor(millis / 1000);
    const ms = millis % 1000;
    
    if (seconds < 60) {
        return `+${seconds}.${ms.toString().padStart(3, '0')}s`;
    }
    
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    
    if (minutes < 60) {
        return `+${minutes}m ${remainingSeconds}s`;
    }
    
    const hours = Math.floor(minutes / 60);
    const remainingMinutes = minutes % 60;
    
    return `+${hours}h ${remainingMinutes}m`;
}

function showErrorDecoderMessage(message) {
    const tableBody = document.getElementById('errorTableBody');
    const noErrorsMsg = document.getElementById('noErrorsMessage');
    const errorSummary = document.getElementById('errorSummary');
    
    if (tableBody) tableBody.innerHTML = '';
    if (noErrorsMsg) {
        noErrorsMsg.innerHTML = message;
        noErrorsMsg.style.display = 'block';
    }
    if (errorSummary) errorSummary.style.display = 'none';
}

function clearErrorDecoder() {
    const inputField = document.getElementById('errorLogInput');
    const tableBody = document.getElementById('errorTableBody');
    const noErrorsMsg = document.getElementById('noErrorsMessage');
    const errorSummary = document.getElementById('errorSummary');
    
    if (inputField) inputField.value = '';
    if (tableBody) tableBody.innerHTML = '';
    if (noErrorsMsg) {
        noErrorsMsg.textContent = 'No errors decoded yet. Paste error log above and click "Decode Errors".';
        noErrorsMsg.style.display = 'block';
    }
    if (errorSummary) errorSummary.style.display = 'none';
}
